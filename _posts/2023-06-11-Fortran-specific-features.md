---
layout: post
title:  "Fortranの言語機能(固有機能編)"
date:   2023-06-11 14:27:40 +0900
categories: プログラミング言語
tag: C C++ Fortran
---
# 導入
今までC言語をメインに触っていたが、ここに来てFortranをやることになったので
自分なりにちゃんとまとめてみようかと思う。

今回は「Fortran特有の機能」という観点でまとめていきたい。

[前回]()

# 前提(再掲)
## 言語規格について
Fortranは今もなお規格が改訂され続けている言語である。今でも使われる主な規格を列挙すると以下が挙げられる。
* FORTRAN 77
* Fortran 90
* Fortran 95
* Fortran 2003
* Fortran 2008
* Fortran 2018
* Fortran 2023(これを書いてる間に追加されたが今回は無視する)

ちなみにFORTRAN(全部大文字)ではなくFortranとなっているのがいわゆるModern Fortran[^Modern]である。

規格が改訂されるとともに古い規格が少しづつ廃止されたりリニューアルされたりしているため、比較の際にはFortranの規格ごとの差も載せるようにする。
(CやC++も規格が改訂されているのは同じだが今回は区別しない)

[^Modern]: Fortran 90はFORTRAN 77の仕様を引き継いでいることもあり、Modern FortranはFortran 2003以降とする考え方もある。([参考文献](https://qiita.com/cure_honey/items/e06b89e238c3df3df693))

## 表記について
* "FORTRAN 77"や"Fortran 90"は長いので"F77"や"F90"と略して表記することにする。
* Fortranでは大文字/小文字を区別しないためどちらで書いてもよいのだが、ここでは予約語は全て大文字で表記することにする。
* F77では固定形式だが、それを無視した書き方になっていることを予めご了承いただきたい。
  * コメントも`!`で統一する。
* スペースの都合で変なところで改行されてしまうが、Fortranでは空白の有無は無視されることがあるが改行すると別の文として扱われるので注意。

# プログラムの構造
CではC99以降制約が撤廃されたが、Fortranでは未だに全ての宣言文は
実行文より前に書かないといけないというルールが存在する。
(さらに細かいことを言うと宣言文の中にも順序が存在する)

ただ、逆にあるプログラムで外部手続きを呼ぶとなったとき、
同じファイル内にあればプロトタイプ宣言(抽象手続引用)がなくてもOKだったりする。

## グローバル変数
Fortranにも似たような概念はある。
ただし、Cのようにグローバル変数は静的領域に、ローカル変数はスタック領域に確保されるといったものはない。

Fortranでは以下のものは大域的要素と呼ばれ、プログラム全体で1つだけ定義できる
* 主プログラム名
* 外部関数名
* サブルーチン名
* 初期値設定副プログラム名
* 共通ブロック

逆にそれ以外はプログラム単位内でのみ有効である。

## 文
上で述べたようにFortranではどのような文をどこに書くかが細かく規定されており、
文の種類についても細かく分類されている。

# 暗黙の型定義
念のため初めに言っておくとこれは型推論ではない。
(どちらかというとスクリプト言語に似た厄介な型システムである)



# 処理の流れを変える
割と廃止されている
* GOTO文
  * 単純
  * 計算形
  * 割当て形
* IF文
* ENTRY文
* 選択戻り指定子
* 入出力文

# 手続き副プログラム(サブルーチン)
Cのvoid型関数と思えばいいが、細かいところで関数とは違いが出てくる

* サブルーチンで仮引数がない場合は`()`を省略できる
  * 関数は省略不可

# 配列
Fortranは性能が出ないコードを誤って書かないようになっているという言説をたまに見るが、
その所以はここにあるかなと思っている。
わざわざDOループを使わずとも簡潔に書けてしまう。そしてコンパイラはそれに対して思いっきり最適化がかけられる。

例えば2次元配列の演算を2重ループでやることを考える。
Cだとforループを使わないといけないので以下のようなコードを書いてしまうことがある。

```c
for (int j = 0; j < N; j++)
  for (int i = 0; i < N; i++)
    c[i][j] = a[i][j] * b[i][j];
```
上記のコードはメモリアクセスの効率が悪く、性能が出ない。
ループを入れ替えてあげれば計算結果を変えずに速度を出すことができる。
(このくらいのレベルであればコンパイラは最適化できてしまうが)

Fortranでも同様のコードは書けてしまうが、大抵の場合、わざわざそんなことはせず以下の1行で済ませる。

```
c = a * b
! F03の自動再割付けにより形状が勝手に変わることがあるため
! 以下の形式を推奨
! c(:,:) = a(:,:) * b(:,:)
```
上の1行だけで、対応する要素ごとに`c = a * b`を計算する、と書けてしまう。(※行列積ではない)
そしてコンパイラはその要件のみを満たす最も効率の良いコードを生成すればよい。

## 部分配列
ベクトル添字

## 配列を引数として渡す
Cだと配列とポインタはほぼ同じようなものなので割と楽(多次元配列はちょっと面倒か)だが、
Fortranは配列を配列として扱う(そもそもF77にはポインタがなかった)。
そのため、配列の形状に関する様々なパターンを考慮していろんな渡し方が存在する。
* 形状明示配列(explicit-shape)
  * ex) `INTEGER :: a(1:10, 101:200)`
  * その名の通り全ての次元において上下限を明示している配列(下限は省略でき、その場合1になる)
    * 変数を指定することもでき、例えば同じ手続の仮引数を指定できる
    * つまり実際の形状が常に同じである必要はない
  * 仮引数として指定している場合、実引数は形状が一致する必要がある
* 形状引継ぎ配列(assumed-shape)
  * ex) `INTEGER :: a(1:, 101:)`
  * 下限だけ指定して各次元の要素数は実引数のものを引継ぐ**配列**(下限を省略することもでき、その場合1になる)
    * これも変数を指定することが可能
    * "配列"というのが大事(後で似たのが出てくる)
  * 仮引数として指定している場合、実引数は次元数が一致する必要がある
* 大きさ引継ぎ配列(assumed-size)
  * ex) `INTEGER :: a(1:10, 101:110, -1:*)`
    * 一番上の次元の上限が`*`
  * 配列全体の要素数だけ実引数のものを引継ぐ配列
    * 一番上の次元で帳尻を合わす
  * Cの配列へのポインタみたいなもの(引数に配列を書くとき一番上の次元は大きさを省略できるというやつ)
    * `int (*a)[10][10]`とか`int func(int a[][10][10]);`
  * 実引数は型が同じでALLOCATABLEでなければなんでも渡せちゃう(?)
* 形状無指定配列(deferred-shape)
  * ex) `INTEGER, ALLOCATABLE :: a(:, :)`
  * 形状引継ぎ配列と同じように見えるが、ALLOCATABLE変数もしくは配列へのポインタのみがこれに該当する
    * 上下限は省略できるのではなく、**指定してはいけない**
      * 上下限は別途ALLOCATE文かポインタ代入で決まる

引数に部分配列は渡せる？

## ループ
FORALL, WHERE, DO CONCURRENT

## 文字列と文字の配列
Cだと文字の配列=文字列だが、Fortranでは全くの別物である。
(C++のstringは？)
